import osmnx as ox
import networkx as nx
import random
from deap import base, creator, tools, algorithms
import math

# 후보 정류장 좌표 (예: {정류장 번호: (위도, 경도)})
stop_coordinates = {
    1: (37.5665, 126.9780),
    2: (37.5700, 126.9768),
    3: (37.5730, 126.9822),
    4: (37.5600, 126.9880),
    5: (37.5580, 126.9825),
    # 필요에 따라 추가 가능
}

# 각 정류장별 대중교통 수요 (예: {정류장 번호: 수요 값})
stop_demand = {
    1: 50,
    2: 30,
    3: 70,
    4: 20,
    5: 40,
    # 필요에 따라 추가 가능
}

# 도로 네트워크 불러오기 (서울시 예제)
G = ox.graph_from_place('Seoul, South Korea', network_type='drive')

# OSMnx 네트워크에서 가장 가까운 노드 찾기
def get_nearest_node(coord):
    return ox.distance.nearest_nodes(G, coord[1], coord[0])

# 정류장 간 최단 경로 거리 계산 함수
def road_distance(coord1, coord2):
    node1 = get_nearest_node(coord1)
    node2 = get_nearest_node(coord2)
    try:
        return nx.shortest_path_length(G, node1, node2, weight='length') / 1000  # 단위: km
    except nx.NetworkXNoPath:
        return float('inf')  # 경로가 없는 경우 매우 큰 값 반환

# 적합도 함수 정의 (총 이동 거리 + 대중교통 수요 충족도 고려)
def evaluate_route_with_demands(individual):
    total_distance = 0
    total_demand = 0

    for i in range(len(individual) - 1):
        stop1 = stop_coordinates[individual[i]]
        stop2 = stop_coordinates[individual[i + 1]]
        distance = road_distance(stop1, stop2)

        if distance == float('inf'):
            return float('inf'),  # 경로가 없을 경우 매우 낮은 적합도 반환

        total_distance += distance
        total_demand += stop_demand.get(individual[i], 0)

    # 마지막 정류장 수요 추가
    total_demand += stop_demand.get(individual[-1], 0)

    # 적합도는 총 이동 거리 최소화와 대중교통 수요 최대화를 혼합한 값 (수요에 가중치를 줄 수 있음)
    return total_distance - 0.1 * total_demand,  # 튜플로 반환

# DEAP 초기화
creator.create("FitnessMin", base.Fitness, weights=(-1.0,))  # 거리 최소화 및 수요 반영
creator.create("Individual", list, fitness=creator.FitnessMin)

toolbox = base.Toolbox()
toolbox.register("attr_stop", lambda: random.choice(list(stop_coordinates.keys())))
toolbox.register("individual", tools.initRepeat, creator.Individual, toolbox.attr_stop, n=5)  # 정류장 수 설정
toolbox.register("population", tools.initRepeat, list, toolbox.individual)

toolbox.register("mate", tools.cxOrdered)
toolbox.register("mutate", tools.mutShuffleIndexes, indpb=0.2)
toolbox.register("select", tools.selTournament, tournsize=3)
toolbox.register("evaluate", evaluate_route_with_demands)

# 알고리즘 실행
population = toolbox.population(n=100)
NGEN = 50
CXPB, MUTPB = 0.7, 0.2

for gen in range(NGEN):
    offspring = toolbox.select(population, len(population))
    offspring = list(map(toolbox.clone, offspring))

    # 교차와 변이 적용
    for child1, child2 in zip(offspring[::2], offspring[1::2]):
        if random.random() < CXPB:
            toolbox.mate(child1, child2)
            del child1.fitness.values
            del child2.fitness.values

    for mutant in offspring:
        if random.random() < MUTPB:
            toolbox.mutate(mutant)
            del mutant.fitness.values

    # 적합도 재평가
    invalid_ind = [ind for ind in offspring if not ind.fitness.valid]
    fitnesses = map(toolbox.evaluate, invalid_ind)
    for ind, fit in zip(invalid_ind, fitnesses):
        ind.fitness.values = fit

    population[:] = offspring

# 최적 노선 출력
best_individual = tools.selBest(population, 1)[0]
print("최적 노선:", best_individual)
print("적합도(총 거리 - 수요):", best_individual.fitness.values[0])
